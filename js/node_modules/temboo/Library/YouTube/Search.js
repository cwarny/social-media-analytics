
var util = require("util");
var choreography = require("temboo/core/choreography");


/*
    ListSearchResults
    Returns a list of search results that match the specified query parameters.
*/


var ListSearchResults = function(session) {
    /*
        Create a new instance of the ListSearchResults Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/Search/ListSearchResults"
    ListSearchResults.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new ListSearchResultsResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new ListSearchResultsInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the ListSearchResults
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var ListSearchResultsInputSet = function() {
    ListSearchResultsInputSet.super_.call(this);
        /*
        Set the value of the APIKey input for this Choreo. ((optional, string) The API Key provided by Google for simple API access when you do not need to access user data.)
        */
        this.set_APIKey = function(value) {
            this.setInput("APIKey", value);
        }

        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth process. This is required for OAuth authentication unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the ChannelID input for this Choreo. ((optional, string) Indicates that the response should only contain resources created by this channel.)
        */
        this.set_ChannelID = function(value) {
            this.setInput("ChannelID", value);
        }

        /*
        Set the value of the ChannelType input for this Choreo. ((optional, string) Restricts a search to a particular type of channel. Valid values are: "any" (returns all channels) and "show" (only retrieves shows).)
        */
        this.set_ChannelType = function(value) {
            this.setInput("ChannelType", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((optional, string) The Client ID provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((optional, string) The Client Secret provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the Fields input for this Choreo. ((optional, string) Allows you to specify a subset of fields to include in the response using an xpath-like syntax (i.e. items/snippet/title).)
        */
        this.set_Fields = function(value) {
            this.setInput("Fields", value);
        }

        /*
        Set the value of the MaxResults input for this Choreo. ((optional, integer) The maximum number of results to return.)
        */
        this.set_MaxResults = function(value) {
            this.setInput("MaxResults", value);
        }

        /*
        Set the value of the Order input for this Choreo. ((optional, string) Indicates how the results are sorted. Valid values are: date, rating, relevance, and viewCount.)
        */
        this.set_Order = function(value) {
            this.setInput("Order", value);
        }

        /*
        Set the value of the PageToken input for this Choreo. ((optional, string) The "nextPageToken" found in the response which is used to page through results.)
        */
        this.set_PageToken = function(value) {
            this.setInput("PageToken", value);
        }

        /*
        Set the value of the Part input for this Choreo. ((optional, string) Specifies a comma-separated list of one or more search resource properties that the API response will include. Part names that you can pass are 'id' and 'snippet' (the default).)
        */
        this.set_Part = function(value) {
            this.setInput("Part", value);
        }

        /*
        Set the value of the PublishedAfter input for this Choreo. ((optional, date) Returns only results created after the specified time (formatted as a RFC 3339 date-time i.e. 1970-01-01T00:00:00Z).)
        */
        this.set_PublishedAfter = function(value) {
            this.setInput("PublishedAfter", value);
        }

        /*
        Set the value of the PublishedBefore input for this Choreo. ((optional, date) Returns only results created before the specified time (formatted as a RFC 3339 date-time i.e. 1970-01-01T00:00:00Z).)
        */
        this.set_PublishedBefore = function(value) {
            this.setInput("PublishedBefore", value);
        }

        /*
        Set the value of the Query input for this Choreo. ((conditional, string) A query string for searching videos.)
        */
        this.set_Query = function(value) {
            this.setInput("Query", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((optional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

        /*
        Set the value of the RegionCode input for this Choreo. ((optional, string) Returns results for the specified country. The parameter value is an ISO 3166-1 alpha-2 country code.)
        */
        this.set_RegionCode = function(value) {
            this.setInput("RegionCode", value);
        }

        /*
        Set the value of the RelatedToVideoID input for this Choreo. ((optional, string) Retrieves a list of videos that are related to this video id. When using this parameter, the Type parameter must be set to video.)
        */
        this.set_RelatedToVideoID = function(value) {
            this.setInput("RelatedToVideoID", value);
        }

        /*
        Set the value of the TopicID input for this Choreo. ((optional, string) Returns only results associated with the specified topic.)
        */
        this.set_TopicID = function(value) {
            this.setInput("TopicID", value);
        }

        /*
        Set the value of the Type input for this Choreo. ((optional, string) Restricts a search query to only retrieve a particular type of resource. The default value is: video,channel,playlist.)
        */
        this.set_Type = function(value) {
            this.setInput("Type", value);
        }

        /*
        Set the value of the VideoCaption input for this Choreo. ((optional, string) Returns filtered results based on whether videos have captions. Valid values are: any (the default), closedCaption (only returns videos with captions), or none (only returns videos without captions).)
        */
        this.set_VideoCaption = function(value) {
            this.setInput("VideoCaption", value);
        }

        /*
        Set the value of the VideoCategoryID input for this Choreo. ((optional, string) Filters video search results based on their category.)
        */
        this.set_VideoCategoryID = function(value) {
            this.setInput("VideoCategoryID", value);
        }

        /*
        Set the value of the VideoDefinition input for this Choreo. ((optional, string) Filters video results based high or standard definition. Valid values are: any, high, or standard.)
        */
        this.set_VideoDefinition = function(value) {
            this.setInput("VideoDefinition", value);
        }

        /*
        Set the value of the VideoDimension input for this Choreo. ((optional, string) Restrict a search to only retrieve 2D or 3D videos. Valid values are: 2d, 3d, or any.)
        */
        this.set_VideoDimension = function(value) {
            this.setInput("VideoDimension", value);
        }

        /*
        Set the value of the VideoDuration input for this Choreo. ((optional, string) Filters search results based on the video duration. Valid values are: any, long, medium, and short.)
        */
        this.set_VideoDuration = function(value) {
            this.setInput("VideoDuration", value);
        }

        /*
        Set the value of the VideoEmbeddable input for this Choreo. ((optional, string) Filters search results to include only videos that can be embedded into a webpage. Valid values are: any (the default) or true (which will enable this filter).)
        */
        this.set_VideoEmbeddable = function(value) {
            this.setInput("VideoEmbeddable", value);
        }

        /*
        Set the value of the VideoLicense input for this Choreo. ((optional, string) Filters search results to only include videos with a particular license. Valid values are: any, creativeCommon, and youtube.)
        */
        this.set_VideoLicense = function(value) {
            this.setInput("VideoLicense", value);
        }

        /*
        Set the value of the VideoSyndicated input for this Choreo. ((optional, string) Filters search results for videos that can be played outside of youtube.com. Valid values are: any (the default) or true (which will enable this filter).)
        */
        this.set_VideoSyndicated = function(value) {
            this.setInput("VideoSyndicated", value);
        }

        /*
        Set the value of the VideoType input for this Choreo. ((optional, string) Filters search results to a particular type of videos. Valid values are: any, episode, and movie.)
        */
        this.set_VideoType = function(value) {
            this.setInput("VideoType", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the ListSearchResults Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var ListSearchResultsResultSet = function(resultStream) {
    ListSearchResultsResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from YouTube.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(ListSearchResults, choreography.Choreography);
util.inherits(ListSearchResultsInputSet, choreography.InputSet);
util.inherits(ListSearchResultsResultSet, choreography.ResultSet);
exports.ListSearchResults = ListSearchResults;




/******************************************************************************
Begin output wrapper classes
******************************************************************************/

/**
 * Utility function, to retrieve the array-type sub-item specified by the key from the parent (array) specified by the item.
 * Returns an empty array if key is not present.
 */
function getSubArrayByKey(item, key) {
	var val = item[key];
	if(val == null) {
		val = new Array();
	}
	return val;
}



/*
 An object representing the user who wrote this comment
 
*/

var GoogleAuthor = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A plain text displayable name for this user
	*/
	this.getDisplayName = function()  {
		return base["displayName"];
	}

	/*
	Whether this user is the same as the authenticated user of which the request was made on behalf
	*/
	this.getIsAuthenticatedUser = function()  {
		return base["isAuthenticatedUser"];
	}

	/*
	This is always drive#user
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	Get the user's profile picture
	*/
	this.getPicture = function()  {
		return new  GooglePicture(base["picture"]);
	}
}


/*
 An object representing a change for a Google Drive resource
 
*/

var GoogleChange = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Whether the file has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	The ID of the file associated with this change
	*/
	this.getFileId = function()  {
		return base["fileId"];
	}

	/*
	The ID of the change
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#change
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this change
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A listing of changes in Google Drive
 
*/

var GoogleChangeList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive change resource
	*/
	this.getChanges = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleChange(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#changeList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The current largest change ID
	*/
	this.getLargestChangeId = function()  {
		return base["largestChangeId"];
	}

	/*
	A link to the next page of changes
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of changes
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A specific child reference
 
*/

var GoogleChild = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link to the child
	*/
	this.getChildLink = function()  {
		return base["childLink"];
	}

	/*
	The ID of the child
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#childReference
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this reference
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
  A listing of child resources
 
*/

var GoogleChildList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive child resource
	*/
	this.getChildren = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleChild(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#childList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of children
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of children
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing a comment on a file
 
*/

var GoogleComment = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get the user who wronte this comment
	*/
	this.getAuthor = function()  {
		return new  GoogleAuthor(base["author"]);
	}

	/*
	The ID of the comment
	*/
	this.getCommentId = function()  {
		return base["commentId"];
	}

	/*
	The plain text content used to create this comment
	*/
	this.getContent = function()  {
		return base["content"];
	}

	/*
	The date when this comment was first created (formatted RFC 3339 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether this comment has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	The file which this comment is addressing
	*/
	this.getFileId = function()  {
		return base["fileId"];
	}

	/*
	The title of the file which this comment is addressing
	*/
	this.getFileTitle = function()  {
		return base["fileTitle"];
	}

	/*
	HTML formatted content for this comment
	*/
	this.getHtmlContent = function()  {
		return base["htmlContent"];
	}

	/*
	This is always drive#comment
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The date when this comment or any of its replies were last modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Get replies for this comment
	*/
	this.getReplies = function()  {
		var listEntries = base["replies"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleReply(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The status of this comment (open or resolved)
	*/
	this.getStatus = function()  {
		return base["status"];
	}
}


/*
 A list of comments for a file
 
*/

var GoogleCommentList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A Google Drive comment resource
	*/
	this.getComments = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleComment(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#commentList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The page token for the next page of comments
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}
}


/*
 Links for exporting Google Docs to specific formats
 
*/

var GoogleExportLinks = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link to the file in pdf format
	*/
	this.getPdfLink = function()  {
		return base["application/pdf"];
	}

	/*
	A link to the file in rtf format
	*/
	this.getRtfLink = function()  {
		return base["application/rtf"];
	}

	/*
	A link to the file in odt format
	*/
	this.getOdtLink = function()  {
		return base["application/vnd.oasis.opendocument.text"];
	}

	/*
	A link to the file in xlsx format
	*/
	this.getXlsxLink = function()  {
		return base["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"];
	}

	/*
	A link to the file in docx format
	*/
	this.getDocxLink = function()  {
		return base["application/vnd.openxmlformats-officedocument.wordprocessingml.document"];
	}

	/*
	A link to the file in ods format
	*/
	this.getOdsLink = function()  {
		return base["application/x-vnd.oasis.opendocument.spreadsheet"];
	}

	/*
	A link to the file in html format
	*/
	this.getHtmlLink = function()  {
		return base["text/html"];
	}

	/*
	A link to the file in txt format
	*/
	this.getTxtLink = function()  {
		return base["text/plain"];
	}
}


/*
 A complete Google Drive file resource
 
*/

var GoogleFile = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link for opening the file in using a relevant Google editor or viewer
	*/
	this.getAlternateLink = function()  {
		return base["alternateLink"];
	}

	/*
	Create time for this file (formatted ISO8601 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether the file can be edited by the current user
	*/
	this.getEditable = function()  {
		return base["editable"];
	}

	/*
	A link for embedding the file
	*/
	this.getEmbedLink = function()  {
		return base["embedLink"];
	}

	/*
	ETag of the file
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Link for exporting Google Docs to specific formats
	*/
	this.getExportLinks = function()  {
		return new  GoogleExportLinks(base["exportLinks"]);
	}

	/*
	A link to the file's icon
	*/
	this.getIconLink = function()  {
		return base["iconLink"];
	}

	/*
	The ID of the file
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	The type of file (this is always drive#file)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	this.getLabels = function()  {
		return new  GoogleLabels(base["labels"]);
	}

	/*
	Name of the last user to modify this file. This will only be populated if a user has edited this file
	*/
	this.getLastModifyingUserName = function()  {
		return base["lastModifyingUserName"];
	}

	/*
	Last time this file was viewed by the user (formatted RFC 3339 timestamp)
	*/
	this.getLastViewedByMeDate = function()  {
		return base["lastViewedByMeDate"];
	}

	/*
	The mimetype of the file
	*/
	this.getMimeType = function()  {
		return base["mimeType"];
	}

	/*
	Last time this file was modified by the user (formatted RFC 3339 timestamp)
	*/
	this.getModifiedByMeDate = function()  {
		return base["modifiedByMeDate"];
	}

	/*
	Last time this file was modified by anyone (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Name(s) of the owner(s) of this file
	*/
	this.getOwnerNames = function()  {
		var listEntries = base["ownerNames"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = listEntries[i];
			}
		}
		return resultArray;
	}

	/*
	A parent folder which contain this file
	*/
	this.getParents = function()  {
		var listEntries = base["parents"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleParent(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The number of quota bytes used by this file
	*/
	this.getQuotaBytesUsed = function()  {
		return base["quotaBytesUsed"];
	}

	/*
	A link back to this file
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	Whether or not this file is shared
	*/
	this.getShared = function()  {
		return base["shared"];
	}

	/*
	Time at which this file was shared with the user (formatted RFC 3339 timestamp)
	*/
	this.getSharedWithMeDate = function()  {
		return base["sharedWithMeDate"];
	}

	/*
	A link to the file's thumbnail
	*/
	this.getThumbnailLink = function()  {
		return base["thumbnailLink"];
	}

	/*
	The title of the this file
	*/
	this.getTitle = function()  {
		return base["title"];
	}

	/*
	The permissions for the authenticated user on this file.
	*/
	this.getUserPermission = function()  {
		return new  GoogleUserPermission(base["userPermission"]);
	}

	/*
	Whether writers can share the document with other users
	*/
	this.getWritersCanShare = function()  {
		return base["writersCanShare"];
	}
}


/*
 A listing of files in Google Drive
 
*/

var GoogleFileList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive file resource
	*/
	this.getFiles = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleFile(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The type of resource (this is always rive#fileList)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of files
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of files
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A label for the file
   
*/

var GoogleLabels = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Whether or not the file is hidden
	*/
	this.getHidden = function()  {
		return base["hidden"];
	}

	/*
	Whether or not the file is restricted
	*/
	this.getRestricted = function()  {
		return base["restricted"];
	}

	/*
	Whether or not the file is starred
	*/
	this.getStarred = function()  {
		return base["starred"];
	}

	/*
	Whether or not the file is trashed
	*/
	this.getTrashed = function()  {
		return base["trashed"];
	}

	/*
	Whether or not the file is viewed
	*/
	this.getViewed = function()  {
		return base["viewed"];
	}
}


/*
 An object containing a parent resource
 
*/

var GoogleParent = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The id of the folder
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	Whether or not this folder is the root
	*/
	this.getIsRoot = function()  {
		return base["isRoot"];
	}

	/*
	The type of resource
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The link to the parent
	*/
	this.getParentLink = function()  {
		return base["parentLink"];
	}

	/*
	A link back to this reference
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A list of parent resources
 
*/

var GoogleParentList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive parent resource
	*/
	this.getParents = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleParent(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The type of resource (this is always drive#parentList)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing a permission resource
 
*/

var GooglePermission = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the permission
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	The ID of the permission
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#permission
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The name for this permission
	*/
	this.getName = function()  {
		return base["name"];
	}

	/*
	The primary role for this user. Allowed values are: owner, reader, and writer
	*/
	this.getRole = function()  {
		return base["role"];
	}

	/*
	A link back to this permission
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	The account type. Allowed values are: user, group, domain, and anyone
	*/
	this.getType = function()  {
		return base["type"];
	}
}


/*
 A list of permission for a file
 
*/

var GooglePermissionList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive permission resource
	*/
	this.getPermissions = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GooglePermission(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#permissionList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing the user's profile picture
   
*/

var GooglePicture = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A URL that points to a profile picture of this user
	*/
	this.getUrl = function()  {
		return base["url"];
	}
}


/*
 An object representing a reply to a comment
 
*/

var GoogleReply = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get the user who wronte this comment
	*/
	this.getAuthor = function()  {
		return new  GoogleAuthor(base["author"]);
	}

	/*
	The plain text content used to create this reply
	*/
	this.getContent = function()  {
		return base["content"];
	}

	/*
	The date when this reply was first created (formatted RFC 3339 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether this reply has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	HTML formatted content for this reply
	*/
	this.getHtmlContent = function()  {
		return base["htmlContent"];
	}

	/*
	This is always drive#commentReply
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The date when this reply was last modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	The ID of the reply
	*/
	this.getReplyId = function()  {
		return base["replyId"];
	}
}


/*
 A list of replies to a specified comment on a file
 
*/

var GoogleReplyList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get a reply to a Google Drive comment
	*/
	this.getReplies = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleReply(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#commentReplyList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of replies
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of replies
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}
}


/*
 An object representing a revision of a file
 
*/

var GoogleRevision = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the revision
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	Get links for exporting Google Docs to specific formats
	*/
	this.getExportLinks = function()  {
		return new  GoogleExportLinks(base["exportLinks"]);
	}

	/*
	The ID of the revision
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#revision
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	Name of the last user to modify this revision
	*/
	this.getLastModifyingUserName = function()  {
		return base["lastModifyingUserName"];
	}

	/*
	The MIME type of the revision
	*/
	this.getMimeType = function()  {
		return base["mimeType"];
	}

	/*
	Last time this revision was modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Whether this revision is published
	*/
	this.getPublished = function()  {
		return base["published"];
	}

	/*
	A link back to this revision
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A list of a file's revisions
 
*/

var GoogleRevisionList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	Get a revision for a file
	*/
	this.getRevisions = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleRevision(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#revisionList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object containing a permission resource
 
*/

var GoogleUserPermission = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the permission
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	The ID of the permission
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	The type of resource (this is always drive#permission)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The primary role for this user. Allowed values are: owner, reader, writer
	*/
	this.getRole = function()  {
		return base["role"];
	}

	/*
	A link back to this permission
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	The account type. Allowed values are: user, group, domain, anyone
	*/
	this.getType = function()  {
		return base["type"];
	}
}


