
var util = require("util");
var choreography = require("temboo/core/choreography");


/*
    ListCategoriesByID
    Returns a list of categories that match the provided IDs.
*/


var ListCategoriesByID = function(session) {
    /*
        Create a new instance of the ListCategoriesByID Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/VideoCategories/ListCategoriesByID"
    ListCategoriesByID.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new ListCategoriesByIDResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new ListCategoriesByIDInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the ListCategoriesByID
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var ListCategoriesByIDInputSet = function() {
    ListCategoriesByIDInputSet.super_.call(this);
        /*
        Set the value of the APIKey input for this Choreo. ((optional, string) The API Key provided by Google for simple API access when you do not need to access user data.)
        */
        this.set_APIKey = function(value) {
            this.setInput("APIKey", value);
        }

        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth process. This is required for OAuth authentication unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the CategoryID input for this Choreo. ((conditional, string) A comma-separated list of the YouTube video category ID(s) that are being retrieved.)
        */
        this.set_CategoryID = function(value) {
            this.setInput("CategoryID", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((conditional, string) The Client ID provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((conditional, string) The Client Secret provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the Fields input for this Choreo. ((optional, string) Allows you to specify a subset of fields to include in the response using an xpath-like syntax (i.e. items/snippet/title).)
        */
        this.set_Fields = function(value) {
            this.setInput("Fields", value);
        }

        /*
        Set the value of the H1 input for this Choreo. ((optional, string) The hl parameter specifies the language that should be used for text values in the API response. The default value is en_US.)
        */
        this.set_H1 = function(value) {
            this.setInput("H1", value);
        }

        /*
        Set the value of the Part input for this Choreo. ((optional, string) Specifies the videoCategory resource parts that the API response will include. Valid values are: id and snippet.)
        */
        this.set_Part = function(value) {
            this.setInput("Part", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((conditional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the ListCategoriesByID Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var ListCategoriesByIDResultSet = function(resultStream) {
    ListCategoriesByIDResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from YouTube.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(ListCategoriesByID, choreography.Choreography);
util.inherits(ListCategoriesByIDInputSet, choreography.InputSet);
util.inherits(ListCategoriesByIDResultSet, choreography.ResultSet);
exports.ListCategoriesByID = ListCategoriesByID;


/*
    ListCategoriesByRegion
    Returns a list of categories available in the specified country.
*/


var ListCategoriesByRegion = function(session) {
    /*
        Create a new instance of the ListCategoriesByRegion Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/VideoCategories/ListCategoriesByRegion"
    ListCategoriesByRegion.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new ListCategoriesByRegionResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new ListCategoriesByRegionInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the ListCategoriesByRegion
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var ListCategoriesByRegionInputSet = function() {
    ListCategoriesByRegionInputSet.super_.call(this);
        /*
        Set the value of the APIKey input for this Choreo. ((optional, string) The API Key provided by Google for simple API access when you do not need to access user data.)
        */
        this.set_APIKey = function(value) {
            this.setInput("APIKey", value);
        }

        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth process. This is required for OAuth authentication unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((conditional, string) The Client ID provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((conditional, string) The Client Secret provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the Fields input for this Choreo. ((optional, string) Allows you to specify a subset of fields to include in the response using an xpath-like syntax (i.e. items/snippet/title).)
        */
        this.set_Fields = function(value) {
            this.setInput("Fields", value);
        }

        /*
        Set the value of the H1 input for this Choreo. ((optional, string) The hl parameter specifies the language that should be used for text values in the API response. The default value is en_US.)
        */
        this.set_H1 = function(value) {
            this.setInput("H1", value);
        }

        /*
        Set the value of the Part input for this Choreo. ((optional, string) Specifies the videoCategory resource parts that the API response will include. Valid values are: id and snippet.)
        */
        this.set_Part = function(value) {
            this.setInput("Part", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((conditional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

        /*
        Set the value of the RegionCode input for this Choreo. ((conditional, string) Indicates to return the list of video categories available in the specified country. The parameter value is an ISO 3166-1 alpha-2 country code.)
        */
        this.set_RegionCode = function(value) {
            this.setInput("RegionCode", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the ListCategoriesByRegion Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var ListCategoriesByRegionResultSet = function(resultStream) {
    ListCategoriesByRegionResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from YouTube.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(ListCategoriesByRegion, choreography.Choreography);
util.inherits(ListCategoriesByRegionInputSet, choreography.InputSet);
util.inherits(ListCategoriesByRegionResultSet, choreography.ResultSet);
exports.ListCategoriesByRegion = ListCategoriesByRegion;




/******************************************************************************
Begin output wrapper classes
******************************************************************************/

/**
 * Utility function, to retrieve the array-type sub-item specified by the key from the parent (array) specified by the item.
 * Returns an empty array if key is not present.
 */
function getSubArrayByKey(item, key) {
	var val = item[key];
	if(val == null) {
		val = new Array();
	}
	return val;
}



/*
 An object representing the user who wrote this comment
 
*/

var GoogleAuthor = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A plain text displayable name for this user
	*/
	this.getDisplayName = function()  {
		return base["displayName"];
	}

	/*
	Whether this user is the same as the authenticated user of which the request was made on behalf
	*/
	this.getIsAuthenticatedUser = function()  {
		return base["isAuthenticatedUser"];
	}

	/*
	This is always drive#user
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	Get the user's profile picture
	*/
	this.getPicture = function()  {
		return new  GooglePicture(base["picture"]);
	}
}


/*
 An object representing a change for a Google Drive resource
 
*/

var GoogleChange = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Whether the file has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	The ID of the file associated with this change
	*/
	this.getFileId = function()  {
		return base["fileId"];
	}

	/*
	The ID of the change
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#change
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this change
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A listing of changes in Google Drive
 
*/

var GoogleChangeList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive change resource
	*/
	this.getChanges = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleChange(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#changeList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The current largest change ID
	*/
	this.getLargestChangeId = function()  {
		return base["largestChangeId"];
	}

	/*
	A link to the next page of changes
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of changes
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A specific child reference
 
*/

var GoogleChild = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link to the child
	*/
	this.getChildLink = function()  {
		return base["childLink"];
	}

	/*
	The ID of the child
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#childReference
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this reference
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
  A listing of child resources
 
*/

var GoogleChildList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive child resource
	*/
	this.getChildren = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleChild(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#childList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of children
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of children
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing a comment on a file
 
*/

var GoogleComment = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get the user who wronte this comment
	*/
	this.getAuthor = function()  {
		return new  GoogleAuthor(base["author"]);
	}

	/*
	The ID of the comment
	*/
	this.getCommentId = function()  {
		return base["commentId"];
	}

	/*
	The plain text content used to create this comment
	*/
	this.getContent = function()  {
		return base["content"];
	}

	/*
	The date when this comment was first created (formatted RFC 3339 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether this comment has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	The file which this comment is addressing
	*/
	this.getFileId = function()  {
		return base["fileId"];
	}

	/*
	The title of the file which this comment is addressing
	*/
	this.getFileTitle = function()  {
		return base["fileTitle"];
	}

	/*
	HTML formatted content for this comment
	*/
	this.getHtmlContent = function()  {
		return base["htmlContent"];
	}

	/*
	This is always drive#comment
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The date when this comment or any of its replies were last modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Get replies for this comment
	*/
	this.getReplies = function()  {
		var listEntries = base["replies"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleReply(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The status of this comment (open or resolved)
	*/
	this.getStatus = function()  {
		return base["status"];
	}
}


/*
 A list of comments for a file
 
*/

var GoogleCommentList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A Google Drive comment resource
	*/
	this.getComments = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleComment(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#commentList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The page token for the next page of comments
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}
}


/*
 Links for exporting Google Docs to specific formats
 
*/

var GoogleExportLinks = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link to the file in pdf format
	*/
	this.getPdfLink = function()  {
		return base["application/pdf"];
	}

	/*
	A link to the file in rtf format
	*/
	this.getRtfLink = function()  {
		return base["application/rtf"];
	}

	/*
	A link to the file in odt format
	*/
	this.getOdtLink = function()  {
		return base["application/vnd.oasis.opendocument.text"];
	}

	/*
	A link to the file in xlsx format
	*/
	this.getXlsxLink = function()  {
		return base["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"];
	}

	/*
	A link to the file in docx format
	*/
	this.getDocxLink = function()  {
		return base["application/vnd.openxmlformats-officedocument.wordprocessingml.document"];
	}

	/*
	A link to the file in ods format
	*/
	this.getOdsLink = function()  {
		return base["application/x-vnd.oasis.opendocument.spreadsheet"];
	}

	/*
	A link to the file in html format
	*/
	this.getHtmlLink = function()  {
		return base["text/html"];
	}

	/*
	A link to the file in txt format
	*/
	this.getTxtLink = function()  {
		return base["text/plain"];
	}
}


/*
 A complete Google Drive file resource
 
*/

var GoogleFile = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link for opening the file in using a relevant Google editor or viewer
	*/
	this.getAlternateLink = function()  {
		return base["alternateLink"];
	}

	/*
	Create time for this file (formatted ISO8601 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether the file can be edited by the current user
	*/
	this.getEditable = function()  {
		return base["editable"];
	}

	/*
	A link for embedding the file
	*/
	this.getEmbedLink = function()  {
		return base["embedLink"];
	}

	/*
	ETag of the file
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Link for exporting Google Docs to specific formats
	*/
	this.getExportLinks = function()  {
		return new  GoogleExportLinks(base["exportLinks"]);
	}

	/*
	A link to the file's icon
	*/
	this.getIconLink = function()  {
		return base["iconLink"];
	}

	/*
	The ID of the file
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	The type of file (this is always drive#file)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	this.getLabels = function()  {
		return new  GoogleLabels(base["labels"]);
	}

	/*
	Name of the last user to modify this file. This will only be populated if a user has edited this file
	*/
	this.getLastModifyingUserName = function()  {
		return base["lastModifyingUserName"];
	}

	/*
	Last time this file was viewed by the user (formatted RFC 3339 timestamp)
	*/
	this.getLastViewedByMeDate = function()  {
		return base["lastViewedByMeDate"];
	}

	/*
	The mimetype of the file
	*/
	this.getMimeType = function()  {
		return base["mimeType"];
	}

	/*
	Last time this file was modified by the user (formatted RFC 3339 timestamp)
	*/
	this.getModifiedByMeDate = function()  {
		return base["modifiedByMeDate"];
	}

	/*
	Last time this file was modified by anyone (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Name(s) of the owner(s) of this file
	*/
	this.getOwnerNames = function()  {
		var listEntries = base["ownerNames"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = listEntries[i];
			}
		}
		return resultArray;
	}

	/*
	A parent folder which contain this file
	*/
	this.getParents = function()  {
		var listEntries = base["parents"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleParent(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The number of quota bytes used by this file
	*/
	this.getQuotaBytesUsed = function()  {
		return base["quotaBytesUsed"];
	}

	/*
	A link back to this file
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	Whether or not this file is shared
	*/
	this.getShared = function()  {
		return base["shared"];
	}

	/*
	Time at which this file was shared with the user (formatted RFC 3339 timestamp)
	*/
	this.getSharedWithMeDate = function()  {
		return base["sharedWithMeDate"];
	}

	/*
	A link to the file's thumbnail
	*/
	this.getThumbnailLink = function()  {
		return base["thumbnailLink"];
	}

	/*
	The title of the this file
	*/
	this.getTitle = function()  {
		return base["title"];
	}

	/*
	The permissions for the authenticated user on this file.
	*/
	this.getUserPermission = function()  {
		return new  GoogleUserPermission(base["userPermission"]);
	}

	/*
	Whether writers can share the document with other users
	*/
	this.getWritersCanShare = function()  {
		return base["writersCanShare"];
	}
}


/*
 A listing of files in Google Drive
 
*/

var GoogleFileList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive file resource
	*/
	this.getFiles = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleFile(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The type of resource (this is always rive#fileList)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of files
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of files
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A label for the file
   
*/

var GoogleLabels = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Whether or not the file is hidden
	*/
	this.getHidden = function()  {
		return base["hidden"];
	}

	/*
	Whether or not the file is restricted
	*/
	this.getRestricted = function()  {
		return base["restricted"];
	}

	/*
	Whether or not the file is starred
	*/
	this.getStarred = function()  {
		return base["starred"];
	}

	/*
	Whether or not the file is trashed
	*/
	this.getTrashed = function()  {
		return base["trashed"];
	}

	/*
	Whether or not the file is viewed
	*/
	this.getViewed = function()  {
		return base["viewed"];
	}
}


/*
 An object containing a parent resource
 
*/

var GoogleParent = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The id of the folder
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	Whether or not this folder is the root
	*/
	this.getIsRoot = function()  {
		return base["isRoot"];
	}

	/*
	The type of resource
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The link to the parent
	*/
	this.getParentLink = function()  {
		return base["parentLink"];
	}

	/*
	A link back to this reference
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A list of parent resources
 
*/

var GoogleParentList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive parent resource
	*/
	this.getParents = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleParent(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The type of resource (this is always drive#parentList)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing a permission resource
 
*/

var GooglePermission = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the permission
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	The ID of the permission
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#permission
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The name for this permission
	*/
	this.getName = function()  {
		return base["name"];
	}

	/*
	The primary role for this user. Allowed values are: owner, reader, and writer
	*/
	this.getRole = function()  {
		return base["role"];
	}

	/*
	A link back to this permission
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	The account type. Allowed values are: user, group, domain, and anyone
	*/
	this.getType = function()  {
		return base["type"];
	}
}


/*
 A list of permission for a file
 
*/

var GooglePermissionList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive permission resource
	*/
	this.getPermissions = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GooglePermission(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#permissionList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing the user's profile picture
   
*/

var GooglePicture = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A URL that points to a profile picture of this user
	*/
	this.getUrl = function()  {
		return base["url"];
	}
}


/*
 An object representing a reply to a comment
 
*/

var GoogleReply = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get the user who wronte this comment
	*/
	this.getAuthor = function()  {
		return new  GoogleAuthor(base["author"]);
	}

	/*
	The plain text content used to create this reply
	*/
	this.getContent = function()  {
		return base["content"];
	}

	/*
	The date when this reply was first created (formatted RFC 3339 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether this reply has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	HTML formatted content for this reply
	*/
	this.getHtmlContent = function()  {
		return base["htmlContent"];
	}

	/*
	This is always drive#commentReply
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The date when this reply was last modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	The ID of the reply
	*/
	this.getReplyId = function()  {
		return base["replyId"];
	}
}


/*
 A list of replies to a specified comment on a file
 
*/

var GoogleReplyList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get a reply to a Google Drive comment
	*/
	this.getReplies = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleReply(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#commentReplyList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of replies
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of replies
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}
}


/*
 An object representing a revision of a file
 
*/

var GoogleRevision = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the revision
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	Get links for exporting Google Docs to specific formats
	*/
	this.getExportLinks = function()  {
		return new  GoogleExportLinks(base["exportLinks"]);
	}

	/*
	The ID of the revision
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#revision
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	Name of the last user to modify this revision
	*/
	this.getLastModifyingUserName = function()  {
		return base["lastModifyingUserName"];
	}

	/*
	The MIME type of the revision
	*/
	this.getMimeType = function()  {
		return base["mimeType"];
	}

	/*
	Last time this revision was modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Whether this revision is published
	*/
	this.getPublished = function()  {
		return base["published"];
	}

	/*
	A link back to this revision
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A list of a file's revisions
 
*/

var GoogleRevisionList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	Get a revision for a file
	*/
	this.getRevisions = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleRevision(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#revisionList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object containing a permission resource
 
*/

var GoogleUserPermission = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the permission
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	The ID of the permission
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	The type of resource (this is always drive#permission)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The primary role for this user. Allowed values are: owner, reader, writer
	*/
	this.getRole = function()  {
		return base["role"];
	}

	/*
	A link back to this permission
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	The account type. Allowed values are: user, group, domain, anyone
	*/
	this.getType = function()  {
		return base["type"];
	}
}


