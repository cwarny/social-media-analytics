
var util = require("util");
var choreography = require("temboo/core/choreography");


/*
    DeletePlaylist
    Deletes a YouTube playlist.
*/


var DeletePlaylist = function(session) {
    /*
        Create a new instance of the DeletePlaylist Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/Playlists/DeletePlaylist"
    DeletePlaylist.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new DeletePlaylistResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new DeletePlaylistInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the DeletePlaylist
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var DeletePlaylistInputSet = function() {
    DeletePlaylistInputSet.super_.call(this);
        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth process. This is required for OAuth authentication unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((conditional, string) The Client ID provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((conditional, string) The Client Secret provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the PlaylistID input for this Choreo. ((required, string) The id of the playlist to delete.)
        */
        this.set_PlaylistID = function(value) {
            this.setInput("PlaylistID", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((conditional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the DeletePlaylist Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var DeletePlaylistResultSet = function(resultStream) {
    DeletePlaylistResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from Google.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(DeletePlaylist, choreography.Choreography);
util.inherits(DeletePlaylistInputSet, choreography.InputSet);
util.inherits(DeletePlaylistResultSet, choreography.ResultSet);
exports.DeletePlaylist = DeletePlaylist;


/*
    InsertPlaylist
    Creates a playlist.
*/


var InsertPlaylist = function(session) {
    /*
        Create a new instance of the InsertPlaylist Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/Playlists/InsertPlaylist"
    InsertPlaylist.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new InsertPlaylistResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new InsertPlaylistInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the InsertPlaylist
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var InsertPlaylistInputSet = function() {
    InsertPlaylistInputSet.super_.call(this);
        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth process. This is required for OAuth authentication unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((conditional, string) The Client ID provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((conditional, string) The Client Secret provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the Description input for this Choreo. ((optional, string) The playlist's description.)
        */
        this.set_Description = function(value) {
            this.setInput("Description", value);
        }

        /*
        Set the value of the Fields input for this Choreo. ((optional, string) Allows you to specify a subset of fields to include in the response using an xpath-like syntax (i.e. items/snippet/title).)
        */
        this.set_Fields = function(value) {
            this.setInput("Fields", value);
        }

        /*
        Set the value of the Part input for this Choreo. ((optional, string) A comma-separated list of fields that are being set and that will be returned in the response (i.e. snippet,status).)
        */
        this.set_Part = function(value) {
            this.setInput("Part", value);
        }

        /*
        Set the value of the PrivacyStatus input for this Choreo. ((optional, string) The playlist's privacy status. Valid values are: private or public.)
        */
        this.set_PrivacyStatus = function(value) {
            this.setInput("PrivacyStatus", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((conditional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

        /*
        Set the value of the Title input for this Choreo. ((required, string) The title of the playlist.)
        */
        this.set_Title = function(value) {
            this.setInput("Title", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the InsertPlaylist Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var InsertPlaylistResultSet = function(resultStream) {
    InsertPlaylistResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from Google.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(InsertPlaylist, choreography.Choreography);
util.inherits(InsertPlaylistInputSet, choreography.InputSet);
util.inherits(InsertPlaylistResultSet, choreography.ResultSet);
exports.InsertPlaylist = InsertPlaylist;


/*
    ListMyPlaylists
    Returns a collection of playlists owned by the authenticated user.
*/


var ListMyPlaylists = function(session) {
    /*
        Create a new instance of the ListMyPlaylists Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/Playlists/ListMyPlaylists"
    ListMyPlaylists.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new ListMyPlaylistsResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new ListMyPlaylistsInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the ListMyPlaylists
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var ListMyPlaylistsInputSet = function() {
    ListMyPlaylistsInputSet.super_.call(this);
        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth process. This is required for OAuth authentication unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((conditional, string) The Client ID provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((conditional, string) The Client Secret provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the Fields input for this Choreo. ((optional, string) Allows you to specify a subset of fields to include in the response using an xpath-like syntax (i.e. items/snippet/title).)
        */
        this.set_Fields = function(value) {
            this.setInput("Fields", value);
        }

        /*
        Set the value of the MaxResults input for this Choreo. ((optional, integer) The maximum number of results to return.)
        */
        this.set_MaxResults = function(value) {
            this.setInput("MaxResults", value);
        }

        /*
        Set the value of the PageToken input for this Choreo. ((optional, string) The "nextPageToken" found in the response which is used to page through results.)
        */
        this.set_PageToken = function(value) {
            this.setInput("PageToken", value);
        }

        /*
        Set the value of the Part input for this Choreo. ((optional, string) Specifies a comma-separated list of playlist resource properties that the API response will include. Part names that you can pass are: id, snippet, and status.)
        */
        this.set_Part = function(value) {
            this.setInput("Part", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((conditional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the ListMyPlaylists Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var ListMyPlaylistsResultSet = function(resultStream) {
    ListMyPlaylistsResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from YouTube.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(ListMyPlaylists, choreography.Choreography);
util.inherits(ListMyPlaylistsInputSet, choreography.InputSet);
util.inherits(ListMyPlaylistsResultSet, choreography.ResultSet);
exports.ListMyPlaylists = ListMyPlaylists;


/*
    ListPlaylistsByChannel
    Returns a collection of playlists associated with a specified channel.
*/


var ListPlaylistsByChannel = function(session) {
    /*
        Create a new instance of the ListPlaylistsByChannel Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/Playlists/ListPlaylistsByChannel"
    ListPlaylistsByChannel.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new ListPlaylistsByChannelResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new ListPlaylistsByChannelInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the ListPlaylistsByChannel
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var ListPlaylistsByChannelInputSet = function() {
    ListPlaylistsByChannelInputSet.super_.call(this);
        /*
        Set the value of the APIKey input for this Choreo. ((optional, string) The API Key provided by Google for simple API access when you do not need to access user data.)
        */
        this.set_APIKey = function(value) {
            this.setInput("APIKey", value);
        }

        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth2 process. This is required unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the ChannelID input for this Choreo. ((required, string) Indicates that only the specified channel's playlists should be returned.)
        */
        this.set_ChannelID = function(value) {
            this.setInput("ChannelID", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((conditional, string) The Client ID provided by Google. Required unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((conditional, string) The Client Secret provided by Google. Required unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the Fields input for this Choreo. ((optional, string) Allows you to specify a subset of fields to include in the response using an xpath-like syntax (i.e. items/snippet/title).)
        */
        this.set_Fields = function(value) {
            this.setInput("Fields", value);
        }

        /*
        Set the value of the MaxResults input for this Choreo. ((optional, integer) The maximum number of results to return.)
        */
        this.set_MaxResults = function(value) {
            this.setInput("MaxResults", value);
        }

        /*
        Set the value of the PageToken input for this Choreo. ((optional, string) The "nextPageToken" found in the response which is used to page through results.)
        */
        this.set_PageToken = function(value) {
            this.setInput("PageToken", value);
        }

        /*
        Set the value of the Part input for this Choreo. ((optional, string) Specifies a comma-separated list of playlist resource properties that the API response will include. Part names that you can pass are: id, snippet, and status.)
        */
        this.set_Part = function(value) {
            this.setInput("Part", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((conditional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the ListPlaylistsByChannel Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var ListPlaylistsByChannelResultSet = function(resultStream) {
    ListPlaylistsByChannelResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from YouTube.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(ListPlaylistsByChannel, choreography.Choreography);
util.inherits(ListPlaylistsByChannelInputSet, choreography.InputSet);
util.inherits(ListPlaylistsByChannelResultSet, choreography.ResultSet);
exports.ListPlaylistsByChannel = ListPlaylistsByChannel;


/*
    ListPlaylistsByID
    Returns a collection of playlists that match the provided IDs.
*/


var ListPlaylistsByID = function(session) {
    /*
        Create a new instance of the ListPlaylistsByID Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/Playlists/ListPlaylistsByID"
    ListPlaylistsByID.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new ListPlaylistsByIDResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new ListPlaylistsByIDInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the ListPlaylistsByID
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var ListPlaylistsByIDInputSet = function() {
    ListPlaylistsByIDInputSet.super_.call(this);
        /*
        Set the value of the APIKey input for this Choreo. ((optional, string) The API Key provided by Google for simple API access when you do not need to access user data.)
        */
        this.set_APIKey = function(value) {
            this.setInput("APIKey", value);
        }

        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth process. This is required for OAuth authentication unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((conditional, string) The Client ID provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((conditional, string) The Client Secret provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the Fields input for this Choreo. ((optional, string) Allows you to specify a subset of fields to include in the response using an xpath-like syntax (i.e. items/snippet/title).)
        */
        this.set_Fields = function(value) {
            this.setInput("Fields", value);
        }

        /*
        Set the value of the MaxResults input for this Choreo. ((optional, integer) The maximum number of results to return.)
        */
        this.set_MaxResults = function(value) {
            this.setInput("MaxResults", value);
        }

        /*
        Set the value of the PageToken input for this Choreo. ((optional, string) The "nextPageToken" found in the response which is used to page through results.)
        */
        this.set_PageToken = function(value) {
            this.setInput("PageToken", value);
        }

        /*
        Set the value of the Part input for this Choreo. ((optional, string) Specifies a comma-separated list of playlist resource properties that the API response will include. Part names that you can pass are: id, snippet, and status.)
        */
        this.set_Part = function(value) {
            this.setInput("Part", value);
        }

        /*
        Set the value of the PlaylistID input for this Choreo. ((required, string) A comma-separated list of the YouTube playlist ID(s) for the resource(s) that are being retrieved.)
        */
        this.set_PlaylistID = function(value) {
            this.setInput("PlaylistID", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((conditional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the ListPlaylistsByID Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var ListPlaylistsByIDResultSet = function(resultStream) {
    ListPlaylistsByIDResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from YouTube.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(ListPlaylistsByID, choreography.Choreography);
util.inherits(ListPlaylistsByIDInputSet, choreography.InputSet);
util.inherits(ListPlaylistsByIDResultSet, choreography.ResultSet);
exports.ListPlaylistsByID = ListPlaylistsByID;


/*
    UpdatePlaylist
    Updates a playlist.
*/


var UpdatePlaylist = function(session) {
    /*
        Create a new instance of the UpdatePlaylist Choreo. A TembooSession object, containing a valid
        set of Temboo credentials, must be supplied.
	*/
    var location = "/Library/YouTube/Playlists/UpdatePlaylist"
    UpdatePlaylist.super_.call(this, session, location);

    /*
    Define a callback that will be used to appropriately format the results of this Choreo.
    */
    var newResultSet = function(resultStream) {
        return new UpdatePlaylistResultSet(resultStream);
    }

	/*
	Obtain a new InputSet object, used to specify the input values for an execution of this Choreo.
	*/
    this.newInputSet = function() {
        return new UpdatePlaylistInputSet();
    }
    
	/*
	Execute this Choreo with the specified inputs, calling the specified callback upon success,
	and the specified errorCallback upon error.
	*/
    this.execute = function(inputs, callback, errorCallback) {
        this._execute(inputs, newResultSet, callback, errorCallback);
    }
}


/*
An InputSet with methods appropriate for specifying the inputs to the UpdatePlaylist
Choreo. The InputSet object is used to specify input parameters when executing this Choreo.
*/

var UpdatePlaylistInputSet = function() {
    UpdatePlaylistInputSet.super_.call(this);
        /*
        Set the value of the AccessToken input for this Choreo. ((optional, string) A valid access token retrieved during the OAuth process. This is required for OAuth authentication unless you provide the ClientID, ClientSecret, and RefreshToken to generate a new access token.)
        */
        this.set_AccessToken = function(value) {
            this.setInput("AccessToken", value);
        }

        /*
        Set the value of the ClientID input for this Choreo. ((conditional, string) The Client ID provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientID = function(value) {
            this.setInput("ClientID", value);
        }

        /*
        Set the value of the ClientSecret input for this Choreo. ((conditional, string) The Client Secret provided by Google. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_ClientSecret = function(value) {
            this.setInput("ClientSecret", value);
        }

        /*
        Set the value of the Description input for this Choreo. ((optional, string) The playlist's description.)
        */
        this.set_Description = function(value) {
            this.setInput("Description", value);
        }

        /*
        Set the value of the Fields input for this Choreo. ((optional, string) Allows you to specify a subset of fields to include in the response using an xpath-like syntax (i.e. items/snippet/title).)
        */
        this.set_Fields = function(value) {
            this.setInput("Fields", value);
        }

        /*
        Set the value of the Part input for this Choreo. ((optional, string) A comma-separated list of fields that are being set and that will be returned in the response (i.e. snippet,status).)
        */
        this.set_Part = function(value) {
            this.setInput("Part", value);
        }

        /*
        Set the value of the PlaylistID input for this Choreo. ((required, string) The id of the playlist to update.)
        */
        this.set_PlaylistID = function(value) {
            this.setInput("PlaylistID", value);
        }

        /*
        Set the value of the PrivacyStatus input for this Choreo. ((optional, string) The playlist's privacy status. Valid values are: private or public.)
        */
        this.set_PrivacyStatus = function(value) {
            this.setInput("PrivacyStatus", value);
        }

        /*
        Set the value of the RefreshToken input for this Choreo. ((conditional, string) An OAuth refresh token used to generate a new access token when the original token is expired. Required for OAuth authentication unless providing a valid AccessToken.)
        */
        this.set_RefreshToken = function(value) {
            this.setInput("RefreshToken", value);
        }

        /*
        Set the value of the Title input for this Choreo. ((required, string) The title of the playlist.)
        */
        this.set_Title = function(value) {
            this.setInput("Title", value);
        }

}

/*
A ResultSet with methods tailored to the values returned by the UpdatePlaylist Choreo.
The ResultSet object is used to retrieve the results of a Choreo execution.
*/

var UpdatePlaylistResultSet = function(resultStream) {
    UpdatePlaylistResultSet.super_.call(this, resultStream);    
        /*
        Retrieve the value for the "NewAccessToken" output from this Choreo execution. ((string) Contains a new AccessToken when the RefreshToken is provided.)
        */
        this.get_NewAccessToken = function() {
            return this.getResult("NewAccessToken");
        }
        /*
        Retrieve the value for the "Response" output from this Choreo execution. ((json) The response from Google.)
        */
        this.get_Response = function() {
            return this.getResult("Response");
        }
    /*
    Get a list of files
    */
    this.getFileList = function()  {
    	return new  GoogleFileList(JSON.parse(this.getResult('Response')));
    }
}

util.inherits(UpdatePlaylist, choreography.Choreography);
util.inherits(UpdatePlaylistInputSet, choreography.InputSet);
util.inherits(UpdatePlaylistResultSet, choreography.ResultSet);
exports.UpdatePlaylist = UpdatePlaylist;




/******************************************************************************
Begin output wrapper classes
******************************************************************************/

/**
 * Utility function, to retrieve the array-type sub-item specified by the key from the parent (array) specified by the item.
 * Returns an empty array if key is not present.
 */
function getSubArrayByKey(item, key) {
	var val = item[key];
	if(val == null) {
		val = new Array();
	}
	return val;
}



/*
 An object representing the user who wrote this comment
 
*/

var GoogleAuthor = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A plain text displayable name for this user
	*/
	this.getDisplayName = function()  {
		return base["displayName"];
	}

	/*
	Whether this user is the same as the authenticated user of which the request was made on behalf
	*/
	this.getIsAuthenticatedUser = function()  {
		return base["isAuthenticatedUser"];
	}

	/*
	This is always drive#user
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	Get the user's profile picture
	*/
	this.getPicture = function()  {
		return new  GooglePicture(base["picture"]);
	}
}


/*
 An object representing a change for a Google Drive resource
 
*/

var GoogleChange = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Whether the file has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	The ID of the file associated with this change
	*/
	this.getFileId = function()  {
		return base["fileId"];
	}

	/*
	The ID of the change
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#change
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this change
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A listing of changes in Google Drive
 
*/

var GoogleChangeList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive change resource
	*/
	this.getChanges = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleChange(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#changeList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The current largest change ID
	*/
	this.getLargestChangeId = function()  {
		return base["largestChangeId"];
	}

	/*
	A link to the next page of changes
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of changes
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A specific child reference
 
*/

var GoogleChild = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link to the child
	*/
	this.getChildLink = function()  {
		return base["childLink"];
	}

	/*
	The ID of the child
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#childReference
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this reference
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
  A listing of child resources
 
*/

var GoogleChildList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive child resource
	*/
	this.getChildren = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleChild(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#childList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of children
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of children
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing a comment on a file
 
*/

var GoogleComment = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get the user who wronte this comment
	*/
	this.getAuthor = function()  {
		return new  GoogleAuthor(base["author"]);
	}

	/*
	The ID of the comment
	*/
	this.getCommentId = function()  {
		return base["commentId"];
	}

	/*
	The plain text content used to create this comment
	*/
	this.getContent = function()  {
		return base["content"];
	}

	/*
	The date when this comment was first created (formatted RFC 3339 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether this comment has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	The file which this comment is addressing
	*/
	this.getFileId = function()  {
		return base["fileId"];
	}

	/*
	The title of the file which this comment is addressing
	*/
	this.getFileTitle = function()  {
		return base["fileTitle"];
	}

	/*
	HTML formatted content for this comment
	*/
	this.getHtmlContent = function()  {
		return base["htmlContent"];
	}

	/*
	This is always drive#comment
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The date when this comment or any of its replies were last modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Get replies for this comment
	*/
	this.getReplies = function()  {
		var listEntries = base["replies"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleReply(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The status of this comment (open or resolved)
	*/
	this.getStatus = function()  {
		return base["status"];
	}
}


/*
 A list of comments for a file
 
*/

var GoogleCommentList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A Google Drive comment resource
	*/
	this.getComments = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleComment(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#commentList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The page token for the next page of comments
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}
}


/*
 Links for exporting Google Docs to specific formats
 
*/

var GoogleExportLinks = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link to the file in pdf format
	*/
	this.getPdfLink = function()  {
		return base["application/pdf"];
	}

	/*
	A link to the file in rtf format
	*/
	this.getRtfLink = function()  {
		return base["application/rtf"];
	}

	/*
	A link to the file in odt format
	*/
	this.getOdtLink = function()  {
		return base["application/vnd.oasis.opendocument.text"];
	}

	/*
	A link to the file in xlsx format
	*/
	this.getXlsxLink = function()  {
		return base["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"];
	}

	/*
	A link to the file in docx format
	*/
	this.getDocxLink = function()  {
		return base["application/vnd.openxmlformats-officedocument.wordprocessingml.document"];
	}

	/*
	A link to the file in ods format
	*/
	this.getOdsLink = function()  {
		return base["application/x-vnd.oasis.opendocument.spreadsheet"];
	}

	/*
	A link to the file in html format
	*/
	this.getHtmlLink = function()  {
		return base["text/html"];
	}

	/*
	A link to the file in txt format
	*/
	this.getTxtLink = function()  {
		return base["text/plain"];
	}
}


/*
 A complete Google Drive file resource
 
*/

var GoogleFile = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A link for opening the file in using a relevant Google editor or viewer
	*/
	this.getAlternateLink = function()  {
		return base["alternateLink"];
	}

	/*
	Create time for this file (formatted ISO8601 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether the file can be edited by the current user
	*/
	this.getEditable = function()  {
		return base["editable"];
	}

	/*
	A link for embedding the file
	*/
	this.getEmbedLink = function()  {
		return base["embedLink"];
	}

	/*
	ETag of the file
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Link for exporting Google Docs to specific formats
	*/
	this.getExportLinks = function()  {
		return new  GoogleExportLinks(base["exportLinks"]);
	}

	/*
	A link to the file's icon
	*/
	this.getIconLink = function()  {
		return base["iconLink"];
	}

	/*
	The ID of the file
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	The type of file (this is always drive#file)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	this.getLabels = function()  {
		return new  GoogleLabels(base["labels"]);
	}

	/*
	Name of the last user to modify this file. This will only be populated if a user has edited this file
	*/
	this.getLastModifyingUserName = function()  {
		return base["lastModifyingUserName"];
	}

	/*
	Last time this file was viewed by the user (formatted RFC 3339 timestamp)
	*/
	this.getLastViewedByMeDate = function()  {
		return base["lastViewedByMeDate"];
	}

	/*
	The mimetype of the file
	*/
	this.getMimeType = function()  {
		return base["mimeType"];
	}

	/*
	Last time this file was modified by the user (formatted RFC 3339 timestamp)
	*/
	this.getModifiedByMeDate = function()  {
		return base["modifiedByMeDate"];
	}

	/*
	Last time this file was modified by anyone (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Name(s) of the owner(s) of this file
	*/
	this.getOwnerNames = function()  {
		var listEntries = base["ownerNames"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = listEntries[i];
			}
		}
		return resultArray;
	}

	/*
	A parent folder which contain this file
	*/
	this.getParents = function()  {
		var listEntries = base["parents"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleParent(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The number of quota bytes used by this file
	*/
	this.getQuotaBytesUsed = function()  {
		return base["quotaBytesUsed"];
	}

	/*
	A link back to this file
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	Whether or not this file is shared
	*/
	this.getShared = function()  {
		return base["shared"];
	}

	/*
	Time at which this file was shared with the user (formatted RFC 3339 timestamp)
	*/
	this.getSharedWithMeDate = function()  {
		return base["sharedWithMeDate"];
	}

	/*
	A link to the file's thumbnail
	*/
	this.getThumbnailLink = function()  {
		return base["thumbnailLink"];
	}

	/*
	The title of the this file
	*/
	this.getTitle = function()  {
		return base["title"];
	}

	/*
	The permissions for the authenticated user on this file.
	*/
	this.getUserPermission = function()  {
		return new  GoogleUserPermission(base["userPermission"]);
	}

	/*
	Whether writers can share the document with other users
	*/
	this.getWritersCanShare = function()  {
		return base["writersCanShare"];
	}
}


/*
 A listing of files in Google Drive
 
*/

var GoogleFileList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive file resource
	*/
	this.getFiles = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleFile(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The type of resource (this is always rive#fileList)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of files
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of files
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A label for the file
   
*/

var GoogleLabels = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Whether or not the file is hidden
	*/
	this.getHidden = function()  {
		return base["hidden"];
	}

	/*
	Whether or not the file is restricted
	*/
	this.getRestricted = function()  {
		return base["restricted"];
	}

	/*
	Whether or not the file is starred
	*/
	this.getStarred = function()  {
		return base["starred"];
	}

	/*
	Whether or not the file is trashed
	*/
	this.getTrashed = function()  {
		return base["trashed"];
	}

	/*
	Whether or not the file is viewed
	*/
	this.getViewed = function()  {
		return base["viewed"];
	}
}


/*
 An object containing a parent resource
 
*/

var GoogleParent = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The id of the folder
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	Whether or not this folder is the root
	*/
	this.getIsRoot = function()  {
		return base["isRoot"];
	}

	/*
	The type of resource
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The link to the parent
	*/
	this.getParentLink = function()  {
		return base["parentLink"];
	}

	/*
	A link back to this reference
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A list of parent resources
 
*/

var GoogleParentList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive parent resource
	*/
	this.getParents = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleParent(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	The type of resource (this is always drive#parentList)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing a permission resource
 
*/

var GooglePermission = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the permission
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	The ID of the permission
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#permission
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The name for this permission
	*/
	this.getName = function()  {
		return base["name"];
	}

	/*
	The primary role for this user. Allowed values are: owner, reader, and writer
	*/
	this.getRole = function()  {
		return base["role"];
	}

	/*
	A link back to this permission
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	The account type. Allowed values are: user, group, domain, and anyone
	*/
	this.getType = function()  {
		return base["type"];
	}
}


/*
 A list of permission for a file
 
*/

var GooglePermissionList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	A Google Drive permission resource
	*/
	this.getPermissions = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GooglePermission(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#permissionList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object representing the user's profile picture
   
*/

var GooglePicture = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	A URL that points to a profile picture of this user
	*/
	this.getUrl = function()  {
		return base["url"];
	}
}


/*
 An object representing a reply to a comment
 
*/

var GoogleReply = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get the user who wronte this comment
	*/
	this.getAuthor = function()  {
		return new  GoogleAuthor(base["author"]);
	}

	/*
	The plain text content used to create this reply
	*/
	this.getContent = function()  {
		return base["content"];
	}

	/*
	The date when this reply was first created (formatted RFC 3339 timestamp)
	*/
	this.getCreatedDate = function()  {
		return base["createdDate"];
	}

	/*
	Whether this reply has been deleted
	*/
	this.getDeleted = function()  {
		return base["deleted"];
	}

	/*
	HTML formatted content for this reply
	*/
	this.getHtmlContent = function()  {
		return base["htmlContent"];
	}

	/*
	This is always drive#commentReply
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The date when this reply was last modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	The ID of the reply
	*/
	this.getReplyId = function()  {
		return base["replyId"];
	}
}


/*
 A list of replies to a specified comment on a file
 
*/

var GoogleReplyList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	Get a reply to a Google Drive comment
	*/
	this.getReplies = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleReply(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#commentReplyList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link to the next page of replies
	*/
	this.getNextLink = function()  {
		return base["nextLink"];
	}

	/*
	The page token for the next page of replies
	*/
	this.getNextPageToken = function()  {
		return base["nextPageToken"];
	}
}


/*
 An object representing a revision of a file
 
*/

var GoogleRevision = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the revision
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	Get links for exporting Google Docs to specific formats
	*/
	this.getExportLinks = function()  {
		return new  GoogleExportLinks(base["exportLinks"]);
	}

	/*
	The ID of the revision
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	This is always drive#revision
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	Name of the last user to modify this revision
	*/
	this.getLastModifyingUserName = function()  {
		return base["lastModifyingUserName"];
	}

	/*
	The MIME type of the revision
	*/
	this.getMimeType = function()  {
		return base["mimeType"];
	}

	/*
	Last time this revision was modified (formatted RFC 3339 timestamp)
	*/
	this.getModifiedDate = function()  {
		return base["modifiedDate"];
	}

	/*
	Whether this revision is published
	*/
	this.getPublished = function()  {
		return base["published"];
	}

	/*
	A link back to this revision
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 A list of a file's revisions
 
*/

var GoogleRevisionList = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the list
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	Get a revision for a file
	*/
	this.getRevisions = function()  {
		var listEntries = base["items"];
		var resultArray = new Array();
		if(listEntries != null) {
			for(var i=0; i < listEntries.length; i++) {
				resultArray[i] = new  GoogleRevision(listEntries[i]);
			}
		}
		return resultArray;
	}

	/*
	This is always drive#revisionList
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	A link back to this list
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}
}


/*
 An object containing a permission resource
 
*/

var GoogleUserPermission = function(base) {
	var base = base;
    if(typeof(base) == 'undefined')
        base = new Array();

	this.getBase = function() {
		return base;
	}
	/*
	The ETag of the permission
	*/
	this.getEtag = function()  {
		return base["etag"];
	}

	/*
	The ID of the permission
	*/
	this.getId = function()  {
		return base["id"];
	}

	/*
	The type of resource (this is always drive#permission)
	*/
	this.getKind = function()  {
		return base["kind"];
	}

	/*
	The primary role for this user. Allowed values are: owner, reader, writer
	*/
	this.getRole = function()  {
		return base["role"];
	}

	/*
	A link back to this permission
	*/
	this.getSelfLink = function()  {
		return base["selfLink"];
	}

	/*
	The account type. Allowed values are: user, group, domain, anyone
	*/
	this.getType = function()  {
		return base["type"];
	}
}


